'use client'

import { useEffect, useMemo, useRef, useState, type ReactElement } from 'react'
import { Network, type Data, type Options } from 'vis-network/standalone'
import { useParams, useRouter } from 'next/navigation'
import { useTheme } from 'next-themes'
import type { GraphData } from '@/lib/graph-utils'
import type { LocaleTypes } from '@/app/[locale]/i18n/settings'

// Removed GROUP_BASE_COLORS - using monochromatic design

const hexToRgb = (hex: string) => {
  const normalized = hex.replace('#', '')
  const bigint = parseInt(normalized, 16)
  const r = (bigint >> 16) & 255
  const g = (bigint >> 8) & 255
  const b = bigint & 255
  return { r, g, b }
}

const adjustColor = (hex: string, amount: number) => {
  const { r, g, b } = hexToRgb(hex)
  const clamp = (value: number) => Math.max(0, Math.min(value, 255))
  const mixChannel = (channel: number) => {
    const target = amount < 0 ? 0 : 255
    return clamp(Math.round(channel + (target - channel) * Math.abs(amount)))
  }
  return `rgb(${mixChannel(r)}, ${mixChannel(g)}, ${mixChannel(b)})`
}

const colorWithAlpha = (hex: string, alpha: number) => {
  const { r, g, b } = hexToRgb(hex)
  return `rgba(${r}, ${g}, ${b}, ${alpha})`
}

type VisNodeFont = {
  size?: number
  color?: string
  background?: string
  strokeWidth?: number
}

interface VisNodeDataset {
  get: (id: string) => ({ font?: VisNodeFont } & { id: string }) | null | undefined
  update: (node: { id: string; font?: VisNodeFont }) => void
}

interface GraphViewProps {
  graphData: GraphData
  onNodeClick?: (nodeId: string) => void
  layoutMode?: 'forceAtlas2Based' | 'barnesHut' | 'hierarchicalRepulsion'
  physicsEnabled?: boolean
  forceStrength?: number
}

export default function GraphView({
  graphData,
  onNodeClick,
  layoutMode = 'forceAtlas2Based',
  physicsEnabled = true,
  forceStrength = -13,
}: GraphViewProps): ReactElement {
  const containerRef = useRef<HTMLDivElement>(null)
  const networkRef = useRef<Network | null>(null)
  const { theme } = useTheme()
  const router = useRouter()
  const locale = useParams()?.locale as LocaleTypes
  const [stats, setStats] = useState({ nodes: 0, edges: 0 })
  const [selectedNode, setSelectedNode] = useState<GraphData['nodes'][number] | null>(null)
  const [isFullscreen, setIsFullscreen] = useState(false)
  const [searchQuery, setSearchQuery] = useState('')
  const [highlightedNodes, setHighlightedNodes] = useState<string[]>([])
  const previousHighlightsRef = useRef<string[]>([])
  const isDark = theme === 'dark'

  // Removed groupColors useMemo - using monochromatic design

  const graphBackgroundStyle = useMemo(
    () => ({
      background: isDark ? '#0F172A' : '#FAFAFA', // Flat, clean
    }),
    [isDark]
  )

  const graphPatternStyle = useMemo(
    () => ({
      backgroundImage: isDark
        ? 'radial-gradient(circle at 25% 25%, rgba(255,255,255,0.02) 1px, transparent 70%)'
        : 'radial-gradient(circle at 25% 25%, rgba(15,23,42,0.03) 1px, transparent 70%)',
      backgroundSize: '140px 140px',
      opacity: isDark ? 0.15 : 0.25, // Much more subtle
    }),
    [isDark]
  )
  const graphHeightClass = isFullscreen ? 'h-[calc(100vh-180px)]' : 'h-[700px]' // Increased from 600px for more focus on graph
  const toolbarCardClass = `mb-4 rounded-2xl border ${
    isDark ? 'border-slate-800 bg-slate-900/70' : 'border-slate-200/70 bg-white/80'
  } p-4 shadow-sm backdrop-blur`
  const iconButtonClass = `rounded-xl border ${
    isDark
      ? 'border-slate-700/70 bg-slate-900/60 text-slate-300 hover:bg-slate-800/80'
      : 'border-slate-200 bg-white/80 text-slate-500 hover:bg-white'
  } p-2 transition-colors`
  const overlayCardClass = `rounded-lg px-3 py-2 shadow-sm backdrop-blur ${
    isDark
      ? 'bg-slate-900/60 text-slate-200 border border-slate-800'
      : 'bg-white/90 text-slate-600 border border-slate-200'
  }`
  const mutedTextClass = isDark ? 'text-slate-400' : 'text-slate-500'

  useEffect(() => {
    if (!containerRef.current || !graphData) return

    // Calculate connection counts for each node first
    const connectionCounts = new Map<string, number>()
    graphData.nodes.forEach((node) => {
      connectionCounts.set(node.id, 0)
    })
    graphData.edges.forEach((edge) => {
      connectionCounts.set(edge.from, (connectionCounts.get(edge.from) || 0) + 1)
      connectionCounts.set(edge.to, (connectionCounts.get(edge.to) || 0) + 1)
    })

    const nodes = graphData.nodes.map((node) => {
      const nodeColor = isDark ? '#CBD5E1' : '#475569' // slate-300/600
      const borderColor = isDark ? '#94A3B8' : '#334155' // slate-400/700
      const connectionCount = connectionCounts.get(node.id) || 0

      return {
        id: node.id,
        label: node.label,
        title: `<div style="padding: 8px 10px; font-family: Inter, sans-serif;">
  <strong style="font-size: 13px; display: block; margin-bottom: 4px;">${node.label}</strong>
  <span style="font-size: 11px; color: #94A3B8; display: block; margin-bottom: 4px;">
    ${node.tags.join(' • ')}
  </span>
  <span style="font-size: 10px; color: #64748B;">
    ${connectionCount} ${connectionCount === 1 ? 'connection' : 'connections'}
  </span>
</div>`,
        slug: node.slug,
        tags: node.tags,
        color: {
          background: nodeColor,
          border: borderColor,
          highlight: {
            background: isDark ? '#E2E8F0' : '#1E293B',
            border: isDark ? '#F1F5F9' : '#0F172A',
          },
        },
        font: {
          color: isDark ? '#E2E8F0' : '#0F172A',
          size: 9, // Small size for dense layout (was 12)
          face: 'Inter, system-ui, -apple-system, sans-serif',
          align: 'center', // Center alignment for labels
        },
        shape: 'dot',
        size: Math.min(15, 4 + connectionCount * 0.8), // Size based on connection count (reduced for dense layout)
        shadow: false, // Remove shadows
      }
    })

    const baseEdgeColor = isDark ? 'rgba(148, 163, 184, 0.3)' : 'rgba(148, 163, 184, 0.2)' // More transparent for dense layout (was 0.4/0.25)
    const highlightEdgeColor = isDark ? 'rgba(148, 163, 184, 0.6)' : 'rgba(148, 163, 184, 0.45)' // Adjusted highlight (was 0.7/0.5)
    const edges = graphData.edges.map((edge) => {
      return {
        from: edge.from,
        to: edge.to,
        value: edge.value,
        title: edge.title,
        width: 0.3, // Thinner edges for dense layout (was 0.5)
        color: {
          color: baseEdgeColor,
          hover: highlightEdgeColor,
          highlight: highlightEdgeColor,
          opacity: 0.8, // Slightly more transparent (was 0.85)
        },
        smooth: {
          type: 'continuous' as const,
          roundness: 0.1, // Less curved, more direct (was 0.2)
        },
      }
    })

    const data: Data = { nodes, edges }

    const physicsOptions: NonNullable<Options['physics']> = {
      enabled: physicsEnabled,
      maxVelocity: 35, // Increased from 25 for faster movement in dense layout
      minVelocity: 0.3, // Reduced from 0.5 for finer adjustments
      timestep: 0.5, // Reduced from 0.6 for more frequent calculations
      adaptiveTimestep: true,
      stabilization: {
        enabled: true,
        iterations: 2000, // Increased from 1200 for dense layout stabilization
        updateInterval: 50,
        onlyDynamicEdges: false,
        fit: true,
      },
    }

    const forceMultiplier = forceStrength * 150

    if (layoutMode === 'forceAtlas2Based') {
      physicsOptions.solver = 'forceAtlas2Based'
      physicsOptions.forceAtlas2Based = {
        gravitationalConstant: -50, // Much weaker repulsion for dense layout (was forceMultiplier * 2.5)
        centralGravity: 0.03, // Stronger pull to center (was 0.012)
        springLength: 40, // Much shorter springs for tighter clustering (was 110)
        springConstant: 0.15, // Stronger springs (was 0.08)
        damping: 0.4, // Slightly more damping (was 0.35)
        avoidOverlap: 0.1, // Less overlap avoidance for denser packing (was 0.35)
      }
    } else if (layoutMode === 'barnesHut') {
      physicsOptions.solver = 'barnesHut'
      physicsOptions.barnesHut = {
        gravitationalConstant: -80, // Weaker repulsion for dense layout (was forceMultiplier)
        centralGravity: 0.15, // Stronger pull to center (was 0.08)
        springLength: 50, // Shorter springs (was 140)
        springConstant: 0.08, // Stronger springs (was 0.045)
        damping: 0.35, // Increased damping (was 0.3)
        avoidOverlap: 0.1, // Less overlap avoidance (was 0.2)
      }
    } else if (layoutMode === 'hierarchicalRepulsion') {
      physicsOptions.solver = 'hierarchicalRepulsion'
      physicsOptions.hierarchicalRepulsion = {
        centralGravity: 0,
        springLength: 80, // Reduced from 220 for denser layout
        springConstant: 0.02, // Increased from 0.01
        nodeDistance: 60, // Reduced from 160
        damping: 0.4,
      }
    }

    const options: Options = {
      nodes: {
        borderWidth: 1, // Add subtle border
        borderWidthSelected: 2, // Slightly thicker when selected
        shape: 'dot',
        shadow: false, // Remove shadows
        chosen: {
          node(values, _id, selected, hovering) {
            const baseSize = values.size || 12
            if (hovering || selected) {
              values.size = baseSize * 1.1 // Subtle size increase (was 1.15)
              values.shadow = false // Keep shadows off
              values.font = {
                ...(values.font ?? {}),
                size: 11, // Subtle increase for visibility (was 13)
                color: isDark ? '#F8FAFC' : '#0F172A',
                background: isDark ? 'rgba(15, 23, 42, 0.85)' : 'rgba(255,255,255,0.9)',
                strokeWidth: 0,
              }
            }
          },
        },
      },
      edges: {
        smooth: {
          enabled: true,
          type: 'continuous' as const,
          roundness: 0.1, // Less curved for dense layout (was 0.2)
        },
        shadow: false, // Remove edge shadows
        selectionWidth: 1.2, // More subtle selection (was 1.5)
        color: {
          color: baseEdgeColor,
          opacity: 0.8, // Slightly more transparent (was 0.85)
        },
        chosen: {
          edge(values) {
            values.width = (values.width || 1) + 0.3 // More subtle width increase (was 0.5)
          },
        },
      },
      physics: physicsOptions,
      interaction: {
        hover: true,
        hoverConnectedEdges: true,
        tooltipDelay: 120,
        zoomView: true,
        dragView: true,
        navigationButtons: true,
        keyboard: {
          enabled: true,
          speed: { x: 10, y: 10, zoom: 0.02 },
          bindToWindow: false,
        },
      },
    }

    const network = new Network(containerRef.current, data, options)
    networkRef.current = network

    network.once('stabilizationIterationsDone', () => {
      if (physicsEnabled) {
        network.setOptions({
          physics: {
            enabled: true,
            stabilization: { enabled: false },
          },
        })
      }
    })

    network.on('click', (params) => {
      if (params.nodes.length > 0) {
        const nodeId = params.nodes[0] as string
        const node = graphData.nodes.find((n) => n.id === nodeId)
        if (node) {
          setSelectedNode(node)
          const connectedNodes = network.getConnectedNodes(nodeId) as string[]
          setHighlightedNodes([nodeId, ...connectedNodes])

          // Focus on selected node with subtle zoom animation
          network.focus(nodeId, {
            scale: 1.2,
            animation: {
              duration: 500,
              easingFunction: 'easeInOutQuad',
            },
          })
        }
      } else {
        setSelectedNode(null)
        setHighlightedNodes([])
      }
    })

    network.on('doubleClick', (params) => {
      if (params.nodes.length > 0) {
        const nodeId = params.nodes[0] as string
        const node = graphData.nodes.find((n) => n.id === nodeId)
        if (node && node.slug) {
          if (onNodeClick) {
            onNodeClick(nodeId)
          } else {
            router.push(`/${locale}/blog/${node.slug}`)
          }
        }
      }
    })

    network.on('deselectNode', () => {
      if (network.getSelectedNodes().length === 0) {
        setSelectedNode(null)
        setHighlightedNodes([])
      }
    })

    // Zoom-based label visibility optimization for performance
    let currentScale = 1
    network.on('zoom', (params) => {
      const newScale = params.scale
      if (Math.abs(newScale - currentScale) > 0.1) {
        currentScale = newScale
        const dataset = network.body?.data?.nodes as VisNodeDataset | undefined
        if (!dataset) return

        // Hide labels when very zoomed out for performance (only for larger graphs)
        if (graphData.nodes.length > 50) {
          graphData.nodes.forEach((node) => {
            dataset.update({
              id: node.id,
              font: {
                size: newScale < 0.5 ? 0.01 : 9,
              },
            })
          })
        }
      }
    })

    setStats({
      nodes: graphData.nodes.length,
      edges: graphData.edges.length,
    })

    return () => {
      network.destroy()
    }
  }, [
    graphData,
    theme,
    locale,
    router,
    onNodeClick,
    layoutMode,
    physicsEnabled,
    forceStrength,
    isDark,
  ])

  useEffect(() => {
    const network = networkRef.current
    if (!network) return
    const dataset = network.body?.data?.nodes as VisNodeDataset | undefined
    if (!dataset) return

    const previous = previousHighlightsRef.current
    const toReset = previous.filter((id) => !highlightedNodes.includes(id))
    // Reset previously highlighted nodes to normal visible state (not hidden)
    toReset.forEach((id) => {
      const node = dataset.get(id)
      if (node) {
        dataset.update({
          id,
          font: {
            ...(node.font || {}),
            size: 9, // Keep labels visible at normal size (was 0.01)
            color: isDark ? '#CBD5E1' : '#475569', // Visible color (was undefined)
            background: undefined,
          },
        })
      }
    })

    // Highlight selected nodes with slightly larger, bolded labels
    highlightedNodes.forEach((id) => {
      const node = dataset.get(id)
      if (node) {
        dataset.update({
          id,
          font: {
            ...(node.font || {}),
            size: 11, // More subtle increase (was 13)
            color: isDark ? '#F8FAFC' : '#0F172A',
            background: isDark ? 'rgba(2, 6, 23, 0.82)' : 'rgba(255,255,255,0.9)',
            strokeWidth: 0,
          },
        })
      }
    })

    previousHighlightsRef.current = highlightedNodes
  }, [highlightedNodes, isDark])

  // 搜索功能
  const handleSearch = (query: string) => {
    setSearchQuery(query)
    if (!networkRef.current) return

    if (!query.trim()) {
      setHighlightedNodes([])
      setSelectedNode(null)
      return
    }

    const matchedNodes = graphData.nodes.filter(
      (node) =>
        node.label.toLowerCase().includes(query.toLowerCase()) ||
        node.title.toLowerCase().includes(query.toLowerCase()) ||
        node.tags.some((tag) => tag.toLowerCase().includes(query.toLowerCase()))
    )

    if (matchedNodes.length > 0) {
      const nodeIds = matchedNodes.map((n) => n.id)
      setHighlightedNodes(nodeIds)
      networkRef.current.fit({
        nodes: nodeIds,
        animation: {
          duration: 1000,
          easingFunction: 'easeInOutQuad',
        },
      })
    }
  }

  // 切换全屏
  const toggleFullscreen = () => {
    setIsFullscreen(!isFullscreen)
  }

  // 重置视图
  const resetView = () => {
    if (networkRef.current) {
      networkRef.current.fit({
        animation: {
          duration: 1000,
          easingFunction: 'easeInOutQuad',
        },
      })
    }
  }

  // 聚焦到选中节点
  const focusNode = (nodeId: string) => {
    if (networkRef.current) {
      networkRef.current.focus(nodeId, {
        scale: 1.5,
        animation: {
          duration: 1000,
          easingFunction: 'easeInOutQuad',
        },
      })
    }
  }

  const connectionDensity =
    stats.nodes > 1 ? Math.min(100, (stats.edges / (stats.nodes * (stats.nodes - 1))) * 100) : 0

  return (
    <div
      className={`relative ${isFullscreen ? 'fixed inset-0 z-50 bg-slate-50 dark:bg-slate-950' : ''}`}
    >
      <div className="flex h-full gap-4 max-lg:flex-col">
        {/* 主图谱区域 */}
        <div className="flex flex-1 flex-col">
          {/* 顶部工具栏 - 简洁设计 */}
          <div className={toolbarCardClass}>
            <div className="flex items-center justify-between gap-2">
              {/* 左侧：简洁统计信息 */}
              <div className="text-xs text-slate-600 dark:text-slate-300">
                {stats.nodes} {locale === 'zh' ? '节点' : 'nodes'} • {stats.edges}{' '}
                {locale === 'zh' ? '连接' : 'edges'}
              </div>

              {/* 右侧：基本控制按钮 */}
              <div className="flex items-center gap-1">
                {/* 重置视图按钮 */}
                <button
                  onClick={resetView}
                  className={iconButtonClass}
                  title={locale === 'zh' ? '重置视图' : 'Reset View'}
                >
                  <svg className="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      strokeWidth={2}
                      d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"
                    />
                  </svg>
                </button>

                {/* 全屏按钮 */}
                <button
                  onClick={toggleFullscreen}
                  className={iconButtonClass}
                  title={
                    locale === 'zh'
                      ? isFullscreen
                        ? '退出全屏'
                        : '全屏'
                      : isFullscreen
                        ? 'Exit Fullscreen'
                        : 'Fullscreen'
                  }
                >
                  {isFullscreen ? (
                    <svg className="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path
                        strokeLinecap="round"
                        strokeLinejoin="round"
                        strokeWidth={2}
                        d="M6 18L18 6M6 6l12 12"
                      />
                    </svg>
                  ) : (
                    <svg className="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path
                        strokeLinecap="round"
                        strokeLinejoin="round"
                        strokeWidth={2}
                        d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4"
                      />
                    </svg>
                  )}
                </button>
              </div>
            </div>
          </div>

          {/* 图谱容器 - 霓虹效果 */}
          <div className="relative flex-1">
            <div
              className={`relative w-full ${graphHeightClass} overflow-hidden rounded-3xl border ${
                isDark ? 'border-slate-800' : 'border-slate-200/70'
              } shadow-[0_25px_70px_rgba(15,23,42,0.18)] dark:shadow-[0_25px_70px_rgba(2,6,23,0.65)]`}
            >
              <div className="pointer-events-none absolute inset-0" style={graphBackgroundStyle} />
              <div className="pointer-events-none absolute inset-0" style={graphPatternStyle} />
              <div ref={containerRef} className="relative z-[1] h-full w-full" />

              {!networkRef.current && (
                <div className="absolute inset-0 z-[2] flex items-center justify-center bg-white/80 backdrop-blur-xl dark:bg-slate-950/80">
                  <div className="text-center">
                    <div className="mb-4 inline-block h-12 w-12 animate-spin rounded-full border-4 border-slate-200 border-t-sky-500 dark:border-slate-800 dark:border-t-sky-300" />
                    <p className={`text-sm ${mutedTextClass}`}>
                      {locale === 'zh' ? '加载图谱中...' : 'Loading graph...'}
                    </p>
                  </div>
                </div>
              )}
            </div>
          </div>
        </div>

        {/* 节点详情 - 紧凑浮层 */}
        {selectedNode && (
          <div className="absolute top-20 right-4 w-64 rounded-lg border bg-white/95 dark:bg-slate-900/95 p-3 shadow-lg backdrop-blur z-10">
            <div className="flex items-start justify-between mb-2">
              <h4 className="text-sm font-bold text-slate-900 dark:text-white">
                {selectedNode.label}
              </h4>
              <button
                onClick={() => setSelectedNode(null)}
                className="text-xs text-slate-400 hover:text-slate-600 dark:hover:text-slate-200 transition-colors"
              >
                ✕
              </button>
            </div>
            <p className={`text-xs ${mutedTextClass} mb-2`}>{selectedNode.title}</p>
            <div className="flex flex-wrap gap-1 mb-3">
              {selectedNode.tags.map((tag: string) => (
                <span
                  key={tag}
                  className="text-xs px-1.5 py-0.5 rounded bg-sky-100 dark:bg-sky-900/50 text-sky-700 dark:text-sky-200"
                >
                  {tag}
                </span>
              ))}
            </div>
            <div className={`text-xs ${mutedTextClass} mb-2`}>
              {highlightedNodes.length - 1} {locale === 'zh' ? '个相关节点' : 'related nodes'}
            </div>
            <button
              onClick={() =>
                selectedNode.slug && router.push(`/${locale}/blog/${selectedNode.slug}`)
              }
              className="w-full text-xs py-1.5 rounded bg-sky-500 hover:bg-sky-600 text-white transition-colors"
            >
              {locale === 'zh' ? '查看文章' : 'View Article'}
            </button>
          </div>
        )}
      </div>
    </div>
  )
}
